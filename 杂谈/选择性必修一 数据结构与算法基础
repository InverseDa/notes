## 第一部分 数据结构

### 第一章 数据在计算机的存在形式

本质上，数据存储于内存。内存就像巨大的数组，每个位置都有着数据。但是数据在不同的用途上，使用的方式也不一样。这种方式由建立在数据的数据结构体现出来。

#### 1.1数据结构是数据的载体



#### 1.2常见的数据结构



#### 1.3 抽象数据类型（Abstract Data Type）



#### 1.3复杂度



### 第二章 线性结构

线性结构是最简单的数据结构，常见的线性结构有顺序表、链表、栈和队列。接下来我们会依次讲解这些结构。

#### 2.1 顺序表

顺序表是比较简单的一种数据结构，他的存储形式类似于数组，但具有很多方法（函数），比如$swap(list[i], list[j])$和$getSize(list)$。

顺序表中的数据元素，都是依照内存排列的，所以他们之间在地址上是连续的。因此，顺序表主要还是通过数组实现，即利用数组表头指针创建顺序表。

##### 顺序表的ADT

```
ADT SequenceList
Data:
	ElementType *Sqlist: 顺序表的表头指针
	integer size: 顺序表的长度
Operation:
	InitialList(*Sqlist): 初始化顺序表，建立一个空的顺序表
	ListEmpty(*Sqlist): 判断顺序表是否为空，返回值为布尔类型
	ClearEmpty(*Sqlist): 将顺序表清空
	getElem(*Sqlist, pos): 获取pos位置的元素
	ListInsert(*Sqlist, pos, element): 在第pos位置后面插入一个新的元素elment
	ListDelete(*Sqlist, pos): 删除第pos位置的元素
	getSize(*Sqlist): 获取顺序表的长度
```

##### 顺序表的地址计算方法

由于顺序表的数据元素在地址上都是连续的，因此可以用地址计算来确定他们的位置。

设$LOC$为获得存储位置的函数，那么就有：
$$
LOC(list[i+1])=LOC(list[i])+C
$$
特别地：
$$
LOC(list[i])=LOC(list[0])+iC
$$
其中$C$是数据元素占用的存储单元，由机器决定。

##### 顺序表的获取元素方法

我们先看方法规定：

```
	getElem(*Sqlist, pos): 获取pos位置的元素
```

可以看出，$getElem$方法有表头指针$Sqlist$和$pos$这两个参数。由于数据元素是连续的，因此我们通过$pos$就能确定元素的位置，并且获得其值。



由此，$getElem$方法的时间复杂度显然为$O(1)$



最终，我们给出$getElem$方法的伪代码：

```c++
getElem(*Sqlist, pos):
	return Sqlist[pos];
```

##### 顺序表的插入与删除

#### 2.2链表

##### 单链表的ADT

##### 头结点

##### 单链表的建表与删表

##### 单链表的获取元素方法

##### 单链表的插入与删除

##### 特殊的链表1：静态链表

##### 特殊的链表2：双向链表

#### 2.3栈

##### 顺序栈的ADT

##### 顺序栈的进栈操作

##### 顺序栈的出栈操作

##### 特殊的栈：链栈

##### 栈的应用1：斐波那契数列

##### 栈的应用2：卡特兰数（Catalan Number）

#### 2.4队列

##### 队列的ADT

##### 队列的进队操作

##### 队列的出队操作

##### 特殊的队列：循环队列

### 第三章 树形结构

#### 树

##### 树的定义

##### 结点之间的关系

##### 结点的度

##### 树的ADT

#### 森林

##### 森林的定义



#### 二叉树

##### 二叉树的定义

##### 二叉树的性质

##### 二叉树的ADT

##### 二叉树的存储形式

##### 二叉树的遍历方式

##### 哈夫曼树与哈夫曼编码

### 第四章 图

#### 图的定义

##### 顶点与边的关系

##### 顶点的度

##### 邻接矩阵

##### 无向图

##### 有向图

#### 图的ADT



#### 图的遍历

##### 深度优先遍历

##### 广度优先遍历

##### 

### 第五章 排序

#### 冒泡排序



#### 选择排序



#### 插入排序



#### 归并排序



#### 快速排序



## 第二部分 经典算法基础

### 第六章 复杂度

#### 函数上下界



#### 时间函数



#### 大O表示法



#### 积分近似



#### 递归式



### 第七章 分治法

#### 再谈递归式及其时间复杂度



#### 利用递归树求解时间复杂度



#### 利用主定理求解时间复杂度



#### 最大子数组问题





#### 平面最近点对问题





### 第八章 回溯法

#### NP问题简介



#### 八皇后问题



#### 地图填色问题

##### 地图填色的个数解

##### 四色定理

##### 回溯优化

### 第九章 动态规划

#### 动态规划简介



#### 状态转移方程



#### 利用动态规划解决斐波那契数列问题



#### 利用动态规划解决字符串匹配问题——KMP算法



### 第十章 图算法

#### 并查集

#### Floyd最短距离问题

#### 最短距离问题—迪杰斯特拉算法

#### 流网络简介

#### 最小生成树

##### Prim算法

##### Kruskal算法

##### 
